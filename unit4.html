<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 4: Algorithm Design Techniques</title>
    <style>
        /* General Styles */
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(45deg, #f4f4f9, #e1e5ee);
            color: #333;
            margin: 0;
            padding: 0;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 1rem;
            text-align: center;
        }
        h1 {
            margin: 0;
            font-size: 2rem;
        }
        nav {
            margin-top: 10px;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            font-size: 1rem;
            padding: 0.5rem 1rem;
            border: 1px solid #fff;
            border-radius: 5px;
            background-color: #4a4e69;
            transition: background-color 0.3s ease;
        }
        nav a:hover {
            background-color: #61678f;
        }
        .content {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        h2, h3 {
            color: #4a4e69;
        }
        p {
            line-height: 1.6;
        }

        /* Collapsible Section Styles */
        .collapsible {
            background-color: #4a4e69;
            color: #fff;
            cursor: pointer;
            padding: 10px;
            font-size: 1.2rem;
            border: none;
            width: 100%;
            text-align: left;
            outline: none;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }
        .collapsible:hover {
            background-color: #61678f;
        }
        .collapsible:after {
            content: '\25BC';
            font-weight: bold;
            float: right;
        }
        .collapsible.active:after {
            content: '\25B2';
        }
        .collapsible-content {
            display: none;
            padding: 15px;
            margin-top: 5px;
            border-radius: 12px;
            background-color: #f9f9fb;
            border: 1px solid #ddd;
            transition: max-height 0.2s ease-out;
        }

        /* Code Styling */
        pre {
            background-color: #f4f4f9;
            padding: 10px;
            border-radius: 8px;
            overflow: auto;
            font-size: 1rem;
            color: #333;
            font-family: Consolas, monospace;
        }

        /* Footer Styles */
        footer {
            text-align: center;
            padding: 1rem;
            background-color: #333;
            color: #fff;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <header>
        <h1>Unit 4: Algorithm Design Techniques</h1>
        <nav>
            <a href="index.html">Home</a> <!-- Home button link -->
        </nav>
    </header>

    <div class="content">
        <h2>Overview of Topics</h2>
        <p>In this unit, we explore essential techniques such as <span class="tooltip" data-tooltip="Divides a problem into overlapping subproblems.">Dynamic Programming</span>, <span class="tooltip" data-tooltip="Uses locally optimal choices to solve complex problems.">Greedy Algorithms</span>, and key sorting algorithms. Each approach is foundational to solving complex computational problems efficiently.</p>

        <button class="collapsible">Dynamic Programming</button>
        <div class="collapsible-content">
            <p>Dynamic Programming (DP) is a technique for solving complex problems by breaking them down into simpler subproblems. It is often used for problems with overlapping subproblems and optimal substructure, such as the Knapsack problem and the Longest Common Subsequence.</p>
            <img src="dynamic-programming.jpeg" alt="Dynamic Programming Image" style="width:100%; height:auto; margin-top:10px;">
            <h3>Example Code:</h3>
            <pre><code>def fibonacci(n):
    dp = [0, 1] + [0] * (n - 1)
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
</code></pre>
        </div>

        <button class="collapsible">Greedy Algorithms</button>
        <div class="collapsible-content">
            <p>Greedy Algorithms make a sequence of choices, each of which looks the best at the moment, to find an overall optimal solution. Examples include the Activity Selection Problem and Huffman Coding.</p>
            <img src="greedy.jpeg" alt="Greedy Algorithms Image" style="width:100%; height:auto; margin-top:10px;">
            <h3>Example Code:</h3>
            <pre><code>def activity_selection(activities):
    activities.sort(key=lambda x: x[1])
    selected = [activities[0]]
    for i in range(1, len(activities)):
        if activities[i][0] >= selected[-1][1]:
            selected.append(activities[i])
    return selected
</code></pre>
        </div>

        <button class="collapsible">Sorting Algorithms</button>
        <div class="collapsible-content">
            <p>Sorting algorithms like Merge Sort and Quick Sort are essential for data organization and preprocessing in computer science, offering efficient ways to handle data for further processing.</p>
            <img src="insertion.gif" alt="Sorting Algorithms Image" style="width:100%; height:auto; margin-top:10px;"> <!-- Fixed filename here -->
            <h3>Example Code:</h3>
            <pre><code>def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
</code></pre>
        </div>

        <button class="collapsible">Interview Questions & Answers</button>
        <div class="collapsible-content">
            <h3><strong>Interview Questions</strong></h3>
            <p><strong>Q1:</strong> What is the difference between Dynamic Programming and Greedy Algorithms?</p>
            <p><strong>Answer:</strong> Dynamic Programming solves problems with overlapping subproblems by storing results of subproblems, making it ideal for problems with optimal substructure. Greedy algorithms, on the other hand, make a sequence of locally optimal choices to arrive at a solution and are suitable for optimization problems without needing stored solutions.</p>

            <p><strong>Q2:</strong> Can you give an example where Greedy Algorithm fails?</p>
            <p><strong>Answer:</strong> The Knapsack problem can’t be solved optimally with a Greedy Algorithm, as it doesn’t account for all possible combinations, whereas Dynamic Programming does.</p>

            <p><strong>Q3:</strong> When would you choose Quick Sort over Merge Sort?</p>
            <p><strong>Answer:</strong> Quick Sort is often faster for in-memory sorting due to its partitioning approach and smaller constant factors, whereas Merge Sort is more stable for external sorting as it consistently requires O(n log n) time.</p>
        </div>

        <footer>&copy; 2024 Advanced Data Structures and Algorithms Course</footer>
    </div>

    <script>
        // JavaScript for Collapsible Sections
        document.querySelectorAll(".collapsible").forEach(button => {
            button.addEventListener("click", function() {
                this.classList.toggle("active");
                const content = this.nextElementSibling;
                content.style.display = content.style.display === "block" ? "none" : "block";
                content.style.transition = "max-height 0.3s ease";
            });
        });
    </script>

</body>
</html>
